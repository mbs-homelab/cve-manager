package scheduler

import (
	"cve-manager/database"
	"time"

	log "github.com/sirupsen/logrus"
	"golang.org/x/exp/slices"
	"gorm.io/driver/sqlite"
	"gorm.io/gorm"
)

type Scheduler struct {
	tasks       []Task
	command     chan bool
	currentIdx  int
	minInterval time.Duration
}

type Task struct {
	task func(string)
	id   string
}

func CreateScheduler(interval int) {
	var scheduler = &Scheduler{
		tasks:       make([]Task, 0),
		currentIdx:  0,
		minInterval: 60 * time.Second,
	}
	go func() {
		db, err := gorm.Open(sqlite.Open("test.db"))
		if err != nil {
			panic("Scheduler database connection not succeeded.")
		}
		refreshTasks(scheduler, db)
		ticker := time.NewTicker(scheduler.minInterval)
		for {
			select {
			case <-ticker.C:
				if len(scheduler.tasks) > 0 {
					log.Infof("scheduler on task %d", scheduler.currentIdx)
					ticker.Stop()
					scheduler.tasks[scheduler.currentIdx].task(scheduler.tasks[scheduler.currentIdx].id)
					scheduler.currentIdx++
					if scheduler.currentIdx >= len(scheduler.tasks) {
						scheduler.currentIdx = 0
						refreshTasks(scheduler, db)
					}
					ticker.Reset(scheduler.minInterval)
				}
			}
		}
	}()
}

func (scheduler *Scheduler) Enque(id string, task func(string)) {
	scheduler.tasks = append(scheduler.tasks, Task{id: id, task: task})
}

func (scheduler *Scheduler) Deque(id string) {
	idx := slices.IndexFunc(scheduler.tasks, func(t Task) bool { return t.id == id })
	if idx == -1 {
		return
	}
	scheduler.tasks[idx] = scheduler.tasks[len(scheduler.tasks)-1]
	scheduler.tasks = scheduler.tasks[:len(scheduler.tasks)-1]
}

func refreshTasks(scheduler *Scheduler, db *gorm.DB) {
	var Cpes []database.Cpe
	db.Find(&Cpes)
	if db.Error != nil {
		log.Panicf("Error initializing watchers %w", db.Error)
	}
	log.Infof("Found %d CPEs to watch", len(Cpes))

	scheduler.tasks = nil
	for _, cpe := range Cpes {
		scheduler.Enque(cpe.Cpe, checkCPE)
	}
}
