package scheduler

import (
	"time"

	log "github.com/sirupsen/logrus"
	"golang.org/x/exp/slices"
)

type Scheduler struct {
	tasks       []Task
	command     chan bool
	currentIdx  int
	minInterval time.Duration
}

type Task struct {
	task func(string)
	id   string
}

func CreateScheduler(interval int) *Scheduler {
	var scheduler = &Scheduler{
		tasks:       make([]Task, 0),
		command:     make(chan bool),
		currentIdx:  0,
		minInterval: 60 * time.Second,
	}
	go func() {
		ticker := time.NewTicker(scheduler.minInterval)
		ticker.Stop()
		for {
			select {
			case action := <-scheduler.command:
				if action {
					ticker.Reset(scheduler.minInterval)
				} else {
					ticker.Stop()
				}
			case <-ticker.C:
				log.Debugf("scheduler on task %d", scheduler.currentIdx)
				ticker.Stop()
				scheduler.tasks[scheduler.currentIdx].task(scheduler.tasks[scheduler.currentIdx].id)
				scheduler.currentIdx++
				if scheduler.currentIdx >= len(scheduler.tasks) {
					scheduler.currentIdx = 0
				}
				ticker.Reset(scheduler.minInterval)
			}
		}
	}()
	return scheduler
}

func (scheduler *Scheduler) Enque(id string, task func(string)) {
	scheduler.tasks = append(scheduler.tasks, Task{id: id, task: task})
}

func (scheduler *Scheduler) Deque(id string) {
	idx := slices.IndexFunc(scheduler.tasks, func(t Task) bool { return t.id == id })
	if idx == -1 {
		return
	}
	scheduler.tasks[idx] = scheduler.tasks[len(scheduler.tasks)-1]
	scheduler.tasks = scheduler.tasks[:len(scheduler.tasks)-1]
}

func (scheduler *Scheduler) Start() {
	log.Info("Starting scheduler")
	scheduler.command <- true
}

func (scheduler *Scheduler) Stop() {
	log.Info("Stopping scheduler")
	scheduler.command <- false
}
